// Generated by CoffeeScript 1.9.3
(function() {
  var AnimatableRegion, Backbone, Marionette, NavigationStack, _,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  _ = require('underscore');

  Backbone = require('backbone');

  Marionette = require('backbone.marionette');

  NavigationStack = require('../lib/navigation_stack');

  AnimatableRegion = (function(superClass) {
    extend(AnimatableRegion, superClass);

    function AnimatableRegion(opts) {
      if (opts == null) {
        opts = {};
      }
      _.defaults(opts, {
        showTransitions: true
      });
      this.showTransitions = opts.showTransitions;
      this.navigationStack = new NavigationStack();
      this.transitioning = false;
      AnimatableRegion.__super__.constructor.apply(this, arguments);
    }

    AnimatableRegion.prototype.navigate = function(route, options, history) {
      if (options == null) {
        options = {};
      }
      this.back = false;
      this.navigationOptions = options;
      return history.navigate(route, options);
    };

    AnimatableRegion.prototype.canGoBack = function() {
      return this.navigationStack.length() > 1;
    };

    AnimatableRegion.prototype.goHome = function(route, transition) {
      this.navigationStack.clear();
      this.navigationStack.unshift({
        route: route,
        transition: transition
      });
      return this.goBack(route);
    };

    AnimatableRegion.prototype.goBack = function(route, options) {
      var ref;
      if (options == null) {
        options = {};
      }
      this.back = true;
      this.navigationOptions = options;
      if (route == null) {
        route = (ref = this.navigationStack.get(this.navigationStack.length() - 2)) != null ? ref.route : void 0;
      }
      if (route == null) {
        route = '';
      }
      return window.location.hash = route;
    };

    AnimatableRegion.prototype._empty = function(view, shouldDestroy) {
      if (!this.transitioning) {
        return AnimatableRegion.__super__._empty.apply(this, arguments);
      }
    };

    AnimatableRegion.prototype.show = function(view, options) {
      var ref;
      if (options == null) {
        options = {};
      }
      view._parent = this;
      if (!this.showTransitions) {
        return AnimatableRegion.__super__.show.call(this, view, options);
      }
      this.transition = (ref = this.navigationOptions) != null ? ref.transition : void 0;
      if (this.transition == null) {
        this.transition = view.transition || options.transition;
      }
      this.transitioning = true;
      if (this.transition) {
        this.currentPage = this.currentView;
      }
      return AnimatableRegion.__super__.show.call(this, view, options);
    };

    AnimatableRegion.prototype.attachHtml = function(view) {
      var currentFragment, newPage, previousNavigationItem, ref, ref1;
      currentFragment = Backbone.history.getHash();
      previousNavigationItem = this.navigationStack.unwind(currentFragment);
      if (this.back) {
        this._log('back requested');
      }
      if (this.back || this.back === void 0 && this._isNavigatingBack(currentFragment)) {
        if (!this.back) {
          this._log('back detected');
        }
        this.back = true;
        if (this.navigationStack.length() === 0) {
          this.navigationStack.push({
            route: currentFragment,
            transition: this.transition
          });
        }
        if (((ref = this.navigationOptions) != null ? ref.transition : void 0) == null) {
          this.transition = (previousNavigationItem != null ? previousNavigationItem.transition : void 0) || this.transition;
        }
      } else {
        this.back = false;
        if (!(((ref1 = this.navigationOptions) != null ? ref1.intermediate : void 0) || previousNavigationItem)) {
          this.navigationStack.push({
            route: currentFragment,
            transition: this.transition
          });
        }
      }
      this._log('stack:', this.navigationStack.toString());
      this.navigationOptions = null;
      if (!this.showTransitions || !this.transition) {
        return AnimatableRegion.__super__.attachHtml.call(this, view);
      }
      newPage = view;
      newPage.$el.addClass('page-pre-in');
      newPage.$el.css('z-index', 10);
      this.$el.append(newPage.$el);
      this._log('Using transition', this.transition, 'and back =', this.back);
      if (this.currentPage) {
        this.currentPage.trigger('transitionstart');
        this.$el.addClass("viewport-transitioning viewport-" + this.transition);
        return setTimeout(((function(_this) {
          return function() {
            var cleanupNextPage, cleanupPrevPage;
            window.scrollTo(0, 0);
            _this.currentPage.$el.addClass("animated " + _this.transition + " out" + (_this.back ? ' reverse' : ''));
            newPage.$el.removeClass('page-pre-in');
            newPage.$el.addClass("animated " + _this.transition + " in" + (_this.back ? ' reverse' : ''));
            cleanupNextPage = function() {
              newPage.$el.removeClass("animated " + _this.transition + " in reverse");
              return newPage.$el.css('z-index', '');
            };
            cleanupPrevPage = (function(prevPage) {
              return function() {
                if (prevPage) {
                  if (prevPage.destroy) {
                    return prevPage.destroy();
                  } else {
                    return prevPage.remove();
                  }
                }
              };
            })(_this.currentPage);
            return setTimeout((function() {
              cleanupNextPage();
              cleanupPrevPage();
              _this.currentPage = null;
              _this.back = void 0;
              _this.transitioning = false;
              _this.$el.removeClass('viewport-transitioning');
              _this.$el.removeClass("viewport-" + _this.transition);
              return newPage.trigger('transitioned');
            }), _this._transitionDuration(_this.transition));
          };
        })(this)), 1);
      } else {
        newPage.$el.removeClass('page-pre-in');
        this.back = void 0;
        this.transitioning = false;
        return newPage.trigger('transitioned');
      }
    };

    AnimatableRegion.prototype._isNavigatingBack = function(fragment) {
      var navigationItem;
      if (this.back) {
        return true;
      }
      navigationItem = this.navigationStack.get(this.navigationStack.length() - 1);
      if (!navigationItem) {
        return false;
      }
      return navigationItem.route === fragment;
    };

    AnimatableRegion.prototype._log = function() {
      if (window.navigationStackDebug) {
        Array.prototype.unshift.call(arguments, '[navigation]');
        return console.log.apply(console, arguments);
      }
    };

    AnimatableRegion.prototype._transitionDuration = function(transtionType) {
      if (transtionType === 'flip') {
        return 750;
      }
      return 350;
    };

    return AnimatableRegion;

  })(Marionette.Region);

  module.exports = AnimatableRegion;

}).call(this);
